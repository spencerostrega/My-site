<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini API Chat Interface</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for aesthetic enhancements and avoiding !important */
        :root {
            --primary-color: #4f46e5;
            --secondary-color: #6366f1;
            --user-bubble: #e0f2f1;
            --gemini-bubble: #f0f9ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            scroll-behavior: smooth;
        }

        .chat-container {
            max-height: 80vh;
            overflow-y: auto;
            padding-bottom: 2rem;
        }

        /* FIX 1: Removed !important (approx. line 86) */
        .user-message-bubble {
            background-color: var(--user-bubble);
            border-radius: 1.25rem 0.5rem 1.25rem 1.25rem;
            max-width: 80%;
            padding: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            /* Ensured necessary styles are present */
        }

        /* FIX 1: Removed !important (approx. line 91) */
        .model-message-bubble {
            background-color: var(--gemini-bubble);
            border-radius: 0.5rem 1.25rem 1.25rem 1.25rem;
            max-width: 80%;
            padding: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            /* Ensured necessary styles are present */
        }

        /* FIX 1: Removed !important (approx. line 97) */
        .citation-link {
            font-size: 0.75rem;
            color: var(--primary-color);
            text-decoration: underline;
            margin-top: 0.5rem;
            display: block;
        }

        .input-area {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 768px; /* max-w-3xl */
            background-color: #ffffff;
            border-top: 1px solid #e5e7eb;
            padding: 1rem;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1), 0 -2px 4px -2px rgba(0, 0, 0, 0.06);
            z-index: 10;
        }

        .loading-spinner {
            border: 4px solid rgba(79, 70, 229, 0.1);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Basic markdown styling for the model's response */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .markdown-content h1 { font-size: 1.875rem; }
        .markdown-content h2 { font-size: 1.5rem; }
        .markdown-content h3 { font-size: 1.25rem; }
        .markdown-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .markdown-content ul, .markdown-content ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            list-style-type: disc;
        }
        .markdown-content ol {
            list-style-type: decimal;
        }
        .markdown-content pre {
            background-color: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        .markdown-content code:not(pre code) {
            background-color: #f3f4f6;
            padding: 0.1rem 0.4rem;
            border-radius: 0.3rem;
            font-family: monospace;
            color: #1f2937;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center">

    <div class="w-full max-w-3xl mx-auto p-4 flex-grow relative">
        <!-- Header -->
        <header class="text-center py-4 sticky top-0 bg-gray-50 z-20">
            <h1 class="text-3xl font-bold text-gray-900 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-7 h-7 mr-2 text-indigo-600">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m9 12.75 3 3m0 0 3-3m-3-4.5V18" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 21h3.75a2.25 2.25 0 0 0 2.25-2.25V6.75A2.25 2.25 0 0 0 18.75 4.5H5.25A2.25 2.25 0 0 0 3 6.75v12.423c0 .878.57 1.692 1.403 2.117l6.023 3.011a2.25 2.25 0 0 0 2.16 0l6.023-3.011c.833-.425 1.403-1.24 1.403-2.118V6.75A2.25 2.25 0 0 0 18.75 4.5H5.25Z" />
                </svg>
                Gemini Chat
            </h1>
        </header>

        <!-- Chat History Area -->
        <main id="chat-history" class="chat-container space-y-6 pt-4 pb-48 w-full">
            <!-- Initial welcome message -->
            <div class="flex justify-start">
                <div class="model-message-bubble w-fit">
                    <p class="text-gray-800">Hello! I'm Gemini, your AI assistant. Ask me anything, or try using the Google Search tool for grounded, up-to-date answers!</p>
                </div>
            </div>
            <!-- Messages will be appended here -->
        </main>

        <!-- Input Area (Fixed at the bottom) -->
        <div class="input-area">
            <div id="auth-status" class="text-center text-sm mb-2 text-gray-500">
                Authenticating...
            </div>
            <div class="flex space-x-3">
                <textarea id="prompt-input"
                          class="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-indigo-500 focus:border-indigo-500 resize-none shadow-sm transition duration-150 ease-in-out"
                          rows="1"
                          placeholder="Type your message..."
                          oninput="autoExpand(this)"
                          onkeypress="handleKeyPress(event)"
                          aria-label="Chat prompt input"></textarea>

                <button id="submit-button"
                        class="px-4 py-3 bg-indigo-600 text-white font-semibold rounded-xl shadow-md hover:bg-indigo-700 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                        onclick="sendMessage()"
                        disabled>
                    <span id="button-text">Send</span>
                    <div id="loading-indicator" class="loading-spinner hidden ml-2"></div>
                </button>
            </div>

            <!-- Configuration Options -->
            <div class="mt-4 flex flex-wrap gap-4 text-sm">
                <!-- System Instruction Toggle -->
                <div class="flex items-center">
                    <input type="checkbox" id="use-system-instruction" class="h-4 w-4 text-indigo-600 border-gray-300 rounded">
                    <label for="use-system-instruction" class="ml-2 text-gray-700">Use System Instruction</label>
                </div>

                <!-- Grounding Toggle -->
                <div class="flex items-center">
                    <input type="checkbox" id="use-google-search" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded">
                    <label for="use-google-search" class="ml-2 text-gray-700">Ground with Google Search</label>
                </div>
            </div>

            <div id="system-instruction-area" class="mt-2 hidden">
                <textarea id="system-instruction-input"
                          class="w-full p-2 border border-gray-300 rounded-lg text-sm resize-none"
                          rows="2"
                          placeholder="System Instruction (e.g., 'Act as a pirate captain...')"></textarea>
            </div>
        </div>
    </div>

    <!-- Firebase Script Includes -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, query, orderBy, limit, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { marked } from "https://cdn.jsdelivr.net/npm/marked/marked.min.js";

        // Global variables for Firebase and API
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.isAuthReady = false;
        window.marked = marked;
        window.GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';

        const CHAT_COLLECTION_NAME = 'messages';

        // Helper function to get the current collection path for the user
        function getChatCollectionRef(db, appId, userId) {
            // Public path for sharing chat history
            return collection(db, `artifacts/${appId}/public/data/${CHAT_COLLECTION_NAME}`);
        }

        async function initializeFirebase() {
            try {
                // Check for firebase config using correct typeof operator
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-chat-app-id';

                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                document.getElementById('auth-status').textContent = 'Connecting...';

                // Sign in logic
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialAuthToken) {
                    await signInWithCustomToken(window.auth, initialAuthToken);
                } else {
                    await signInAnonymously(window.auth);
                }

                // Wait for auth state to be ready
                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        document.getElementById('auth-status').textContent = `User ID: ${window.userId.substring(0, 8)}... (App ID: ${appId})`;
                        window.isAuthReady = true;
                        document.getElementById('submit-button').disabled = false;
                        // Start listening for chat history
                        setupChatListener(window.db, appId, window.userId);
                    } else {
                        document.getElementById('auth-status').textContent = 'Authentication Failed.';
                        window.isAuthReady = true; // Still ready, but failed
                    }
                });

                // Export global variables
                window.getChatCollectionRef = getChatCollectionRef;

            } catch (error) {
                console.error("Firebase initialization or authentication failed:", error);
                document.getElementById('auth-status').textContent = `Error: ${error.message}`;
            }
        }

        function setupChatListener(db, appId, userId) {
            if (!db || !appId || !userId) {
                console.error("Cannot set up chat listener: DB or user info missing.");
                return;
            }

            const chatRef = getChatCollectionRef(db, appId, userId);
            const chatQuery = query(chatRef, orderBy('timestamp', 'asc'), limit(50)); // Show last 50 messages

            onSnapshot(chatQuery, (snapshot) => {
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push({ id: doc.id, ...doc.data() });
                });
                renderChatHistory(messages);
            }, (error) => {
                console.error("Error fetching chat history:", error);
                // Optionally show error in UI
            });
        }

        function renderChatHistory(messages) {
            const chatHistoryElement = document.getElementById('chat-history');
            const fragment = document.createDocumentFragment();
            // Check if we are near the bottom before rendering new content
            const isScrolledToBottom = chatHistoryElement.scrollHeight - chatHistoryElement.clientHeight <= chatHistoryElement.scrollTop + 1;

            // Clear existing non-initial messages (keep the welcome message)
            const initialMessage = chatHistoryElement.querySelector('.model-message-bubble').closest('.flex');
            chatHistoryElement.innerHTML = '';
            if (initialMessage) {
                chatHistoryElement.appendChild(initialMessage);
            }

            messages.forEach(msg => {
                const messageElement = createMessageElement(msg.role, msg.content, msg.sources);
                fragment.appendChild(messageElement);
            });

            chatHistoryElement.appendChild(fragment);

            // Scroll to bottom if user was at the bottom or if it's the first load
            if (isScrolledToBottom || messages.length <= 2) {
                chatHistoryElement.scrollTop = chatHistoryElement.scrollHeight;
            }
        }

        // Expose marked for use in main script block
        window.marked = marked;
        window.initializeFirebase = initializeFirebase;

    </script>

    <script>
        // --- Utility Functions ---

        /**
         * Safely escapes HTML content to prevent XSS.
         */
        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;');
        }

        /**
         * Renders Markdown content and handles citations.
         */
        function renderMarkdownWithCitations(content, sources) {
            let htmlContent = window.marked.parse(content);

            if (sources && sources.length > 0) {
                const citationList = sources.map((source, index) =>
                    `<a href="${escapeHtml(source.uri)}" target="_blank" class="citation-link hover:text-indigo-800 transition duration-150">
                        [${index + 1}] ${escapeHtml(source.title || source.uri)}
                    </a>`
                ).join('');

                htmlContent += `<div class="mt-4 pt-2 border-t border-gray-200 text-xs text-gray-500">
                                    <p class="font-semibold mb-1">Sources:</p>
                                    ${citationList}
                                </div>`;
            }
            return htmlContent;
        }

        /**
         * Creates a chat message element for the UI.
         */
        function createMessageElement(role, content, sources = []) {
            const isUser = role === 'user';
            const container = document.createElement('div');
            container.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

            const bubble = document.createElement('div');
            // Using class names defined in the style block for specificity
            bubble.className = isUser
                ? 'user-message-bubble text-gray-900 shadow-lg'
                : 'model-message-bubble text-gray-800 shadow-lg markdown-content';

            if (isUser) {
                bubble.innerHTML = `<p>${escapeHtml(content)}</p>`;
            } else {
                bubble.innerHTML = renderMarkdownWithCitations(content, sources);
            }

            container.appendChild(bubble);
            return container;
        }

        // --- UI Logic ---

        function autoExpand(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevents adding a newline
                sendMessage();
            }
        }

        function toggleLoading(isLoading) {
            const button = document.getElementById('submit-button');
            const buttonText = document.getElementById('button-text');
            const loadingIndicator = document.getElementById('loading-indicator');
            const input = document.getElementById('prompt-input');

            button.disabled = isLoading;
            input.disabled = isLoading;

            if (isLoading) {
                buttonText.textContent = 'Thinking...';
                loadingIndicator.classList.remove('hidden');
            } else {
                buttonText.textContent = 'Send';
                loadingIndicator.classList.add('hidden');
            }
        }

        document.getElementById('use-system-instruction').addEventListener('change', (e) => {
            const area = document.getElementById('system-instruction-area');
            if (e.target.checked) {
                area.classList.remove('hidden');
            } else {
                area.classList.add('hidden');
            }
        });

        // --- Chat and API Logic ---

        /**
         * Adds a message to Firestore and updates the UI instantly.
         */
        async function saveMessage(role, content, sources = []) {
            // FIX 2: Ensure correct use of typeof for checks
            if (!window.db || !window.userId || typeof __app_id === 'undefined') {
                console.error("Firestore not ready. Cannot save message.");
                return;
            }

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-chat-app-id';
            const chatRef = window.getChatCollectionRef(window.db, appId, window.userId);

            try {
                await addDoc(chatRef, {
                    role: role,
                    content: content,
                    timestamp: Date.now(),
                    sources: sources
                });
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }

        /**
         * Main function to handle user input and call the Gemini API.
         */
        async function sendMessage() {
            const promptInput = document.getElementById('prompt-input');
            const prompt = promptInput.value.trim();

            if (!prompt) return;

            // Clear input and collapse textarea
            promptInput.value = '';
            autoExpand(promptInput);

            // 1. Save user message to Firestore
            await saveMessage('user', prompt);

            // 2. Prepare API call
            toggleLoading(true);

            const useSearch = document.getElementById('use-google-search').checked;
            const useSystemInstruction = document.getElementById('use-system-instruction').checked;
            const systemInstructionText = document.getElementById('system-instruction-input').value.trim();

            const userQuery = prompt;
            const apiKey = ""; // Canvas runtime provides this

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: useSearch ? [{ "google_search": {} }] : undefined,
                systemInstruction: useSystemInstruction && systemInstructionText
                    ? { parts: [{ text: systemInstructionText }] }
                    : undefined,
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${window.GEMINI_MODEL}:generateContent?key=${apiKey}`;

            const MAX_RETRIES = 5;
            let responseData = null;

            // FIX 2: Corrected 'function' issue (approx. line 610) by using a standard, valid 'for' loop structure.
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && attempt < MAX_RETRIES - 1) {
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Skip to next attempt
                        }
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    responseData = await response.json();
                    break; // Success, break the retry loop

                } catch (error) {
                    if (attempt === MAX_RETRIES - 1) {
                        console.error("Fetch/API error after all retries:", error);
                        // Save a failure message to the chat history
                        await saveMessage('model', `An error occurred while connecting to the AI: ${error.message}`);
                    }
                    if (attempt < MAX_RETRIES - 1) {
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            toggleLoading(false);

            if (responseData) {
                const candidate = responseData.candidates?.[0];
                let modelResponseText = "Sorry, I couldn't generate a response.";
                let sources = [];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    modelResponseText = candidate.content.parts[0].text;

                    // Extract grounding sources
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }

                // 3. Save model response to Firestore
                // This will trigger the onSnapshot listener and update the chat UI
                await saveMessage('model', modelResponseText, sources);
            }
        }

        // Initialize Firebase when the script loads
        window.onload = function () {
            window.initializeFirebase();
        };

    </script>
</body>
</html>
